Задача 1

В тази задача трябва да реализирате функции работещи с двоично наредено дърво(BST).

Сами изберете начина за представяне на дървото.

Функциите, които трябва да реализирате са изброени по-долу.Сами изберете какви аргументи да им подадете, според това какво представяне на дървото сте избрали.

а) bool isBST(<аргументи>)

Проверява дали даденото дърво е BST.

b) bool isFull(<аргументи>)

Проверява дали двоично дърво е пълно(има максимален брой елементи на всяко ниво)

c) bool ReduceToBst(<аргументи>)

Получава произволно двоично дърво, което може да не е BST.Функцията премахва от него, всички елементи, които развалят наредбата.Ако два елемента в дървото не са в правилна наредба един спрямо друг да се премахва този,който е по-високо в дървото(по-близо до корена). Ако такъв елемент има два наследника, заменете го с максималния елемент на неговото ляво поддърво.

Възможно е да реализирате обхождането на дървото с рекурсия, така и със стек.Във втория случай се позволява да използвате класа  std::stack от STL.





Задача 2 

Имплементирайте функциите 

void add(int key, int value)

Value* getByKey(int key)

за HashTable,  с ключове от тип int, value-та от тип int.

ЖОКЕРИ:

Проста хеш функция -  int hash(int key) { return key % tableSize}



Примерен обект на HashTable + Value обект

struct Value {
T value;
Value* next;

//constructor
}

Node {
int key;
Value value;

//constructor
}